# 渲染器与响应式系统的结合
渲染器顾名思义，就是用来执行渲染任务的。在浏览器中它用来渲染真实DOM。例如下面的函数就是一个合格的渲染函数：
```javascript
function renderer(doString,container){
  container.innerHTML = doString
}
```
并且利用响应式系统，我们可以让这个系统过程自动化：
```javascript
const count = ref(1)
effect(() => {
  renderer(`<h1>${count}</h1>`,document.getElementById('app')
})

count.value++
```
我们利用响应式系统是整个渲染器完成页面的渲染与更新。
# 渲染器的基本概念
我们常使用renderer来表示渲染器，而render只是一个动词，表示渲染。渲染器的作用是把虚拟DOM渲染为特定平台上的真实元素。在浏览器中它用来渲染真实DOM。
虚拟DOM通常用英文vdom来表示，虚拟DOM与真实DOM结构一样，都是由一个个节点组成的树形结构。
渲染器把虚拟DOM渲染为真实DOM 的过程叫挂载，，用mount来表示。
# 自定义渲染器
渲染器不仅能够把虚拟 DOM 渲染为浏览器 平台上的真实 DOM。通过将渲染器设计为可配置的“通用”渲染器，即 可实现渲染到任意目标平台上。
比如说在浏览器中进行渲染，我们需要调用浏览器相关的API。但是为了适配多个平台我们需要为renderer设置一个配置项，用来传入不同平台的API。
```javascript
const renderer = createRenderer({
    //用于创建元素
    createElement(tag){
        return document.createElement(tag)
    },
    //设置元素的文本节点
    setElement(el,text){
        el.innerHTML = text
    },
    //在指定的parent下添加指定元素
    insert(el,parent,anchor = null){
        parent.insertBefore(el,anchor)
    }
})

function createElement(options){
    const {
        createElement,
        insert,
        setElement
    } = options

    /*渲染逻辑  */
}
```
# 渲染器的简单实现
```javascript
function createElement(){
    function render(vnode,container){
        if(vnode){
            //新vnode存在，将其旧vnode传给patch函数，进行打补丁
            patch(container._vnode,vnode,container)
        }else{
            if(container._vnode){
                //旧vnode存在但是新node不存在，说明是卸载操作
                container._vnode = ''
            }
        }
        container._vnode = vnode
    }
    function patch(n1,n2,container){
        //如果n1不存在，说明是挂载，则调用mountElement
        if(!n1){
            mountElement(n2,container)
        }else{
            /*打补丁*/ 
        }
    }
    return render
}
```
```javascript
function mountElement(vnode,container){
    //创建dom元素
    const el =  document.createElement(vnode.type)
    //设置子节点
    if(typeof vnode.children == 'string'){
        el.textContent = vnode.children
    }
    container.appendChild(el)
}
```
